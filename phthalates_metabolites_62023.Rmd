---
title: "Phthalates and Metabolomics data"
output:
  html_document:
    df_print: paged
  author: Ram Siwakoti
---

Date revised: 6/21/2022: Changed column numbers on lines 365, 397, 405, 479: (15 -\> 19); lines 511, 589-590, 812-183: (8-\>12); lines 514, 521, 569, 576, 596, 818, 835-836: (338-\>342); lines 633, 852: (changed to 13); lines 634, 853: (changed to 12); line 755: (339-\>344, 350-\>355)

Date revised: 11/16/2022: Changed revisions from 6/21/2022 back to original numbers 

Date revised: 6/20/2023: Updating file based on phthalates_metabolites_62122. In this version, I took out stuff for unadjusted models. Also took out gam curves for covariates


In this notebook, I will look at the association between phthalates and untargeted metabolites based on the PROTECT data.

I will first set up the working directory and load some libraries


##Options 

```{r options}

source("disable_data_preview.R")

```


## Loading libraries and data import

```{r set up working directory, message = FALSE, warning = FALSE}

setwd("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122")

library(readxl)
library(plyr)
library(tidyselect)
library(visdat) #missing values visualization
library(missForest)
library(ggplot2)
library(tidyr) #converting data from wide to long and vice-versa 
library(directlabels) #to add labels to line plots
library(ggcorrplot) #correlation plots
library(pca3d)
library(gplots)
library(knitr)
library(Hmisc)
library(mgcv)
library(glmnet)
library(kableExtra)
library(purrr)
library(dplyr)

conflicted::conflict_prefer("summarise", "dplyr")
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("group_by", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("mutate", "dplyr")
conflicted::conflict_prefer("arrange", "dplyr")
conflicted::conflict_prefer("rename", "dplyr")


```

Load analytic files created in analytic_file_creation.R.

```{r load analytic files}

phthalates4_wide2 <- readRDS("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122/phthalates4_wide2.rds")
sg <- readRDS("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122/sg3.rds")
metabolites_t <- readRDS("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122/metabolites_t.rds")
phthalates_met <- readRDS("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122/phthalates_met.rds")
blod_summary <- readRDS("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122/blod_summary.rds")
covars <- readRDS("C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/data_62122/covars2.rds")
# classes <- readxl::read_excel("all_metabolites_with_class_info.xlsx", sheet = "Sheet1")
classes <- readxl::read_excel("significant_metabolites_with_class_annotated.xlsx", sheet = "classes_all_metabolites")
classes_short <- classes %>% select(Metabolites, Class_new2) %>% mutate(Metabolites = toupper(Metabolites))

```

##First look at metabolomics data

First we will work on the metabolomics data

Added on 4/14/2022: Check for any duplicate metabolites

```{r duplicate metabolites}

head(metabolites_t %>% select(contains(".1")))

```

Looks like there are 4 duplicate metabolites. I am not sure what is going on here. I will include both duplicates for now (Added on 5/31/2022: out of these 4, only 1 metabolite is identified as significant in the downstream analysis).

Note: For consistency with cord blood data, I will remove all duplicates. For these four metabolites, I will only keep the metabolites without ".1" in their names 

```{r remove duplicates from 4 metabolites}

metabolites_t <- metabolites_t %>% select(!contains(".1"))

```

Let us check missing values and calculate some data summary

```{r metabolomics data mean/missing values check}

#function to calculate geometric mean

geomean <- function(x){
  gm  = exp(mean(log(x), na.rm = TRUE))
  return(gm)
}


sumstats <- function(x){
  Mean = apply(x, 2, function(x) mean(x, na.rm = TRUE))
  GeoMean = apply(x, 2, geomean)
  SD = apply(x, 2, function(x) sd(x, na.rm = TRUE))
  CV = apply(x, 2, function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))
  min = apply(x, 2, function(x) min(x, na.rm = TRUE))
  max = apply(x, 2, function(x) max(x, na.rm = TRUE))
  result <- data.frame(Mean, GeoMean, SD, CV, min, max)
  return(result)
}

#Get the mean of each metabolite

sum_metab <- sumstats(metabolites_t[,4:ncol(metabolites_t)])

mean1 <- apply(metabolites_t[,4:336], MARGIN = 2, geomean) 
cv <- apply(metabolites_t[,4:336], MARGIN = 2, function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))
plot(mean1, xlab = "Metabolite", ylab = "Geometric mean", main = "Visualzing means of different metabolites")
# plot(cv, xlab = "Metabolite", ylab = "CV", main = "Visualzing CVs of different metabolites")



```

From the means plot above, it is sure we need to normalize individual metabolites in some form. Maybe log-transformation.

Look at the pattern of missing data

```{r missing data}

#function to calculate total number of missing values

misssum <- function(x){
  sum <- sum(is.na(x))
}

misssum1 <- apply(metabolites_t[,4:336], MARGIN = 2, misssum)
misssum1_per <- misssum1/100*100
misssum1_per[misssum1_per == max(misssum1_per)]

misssum2 <- apply(metabolites_t[,4:336], MARGIN = 1, misssum)
misssum2_per <- misssum2/332*100
misssum2_per[misssum2_per == max(misssum2_per)]

vis_miss(metabolites_t)



#number of total metabolites with missing values

sum(misssum1>0)

#total number of samples with missing values

sum(misssum2 >0)

```


Sample #2324 is missing 53% of metabolites. Additionally, there are few other metabolites that are missing for a large number of samples

```{R looking at metabolites missing in a large number of samples}

miss_gtx <- misssum1_per[misssum1_per > 30]
miss_gtx_names <- names(miss_gtx)
miss_gtx

miss_gtx2 <- misssum1_per[misssum1_per < 30]


```

The names of FA (X:Y) fatty acids, CAR(10:2), DG(33:1) with more than 30% data missing are (<https://www.metabolomicsworkbench.org/databases/refmet/lipid_classes.php>):

FA(16:1): Unsaturated fatty acid; Palmitoleic acid FA(22:0): Saturated fatty acid; Behenic acid (docosanoic acid) FA(24:6): Unsaturated fatty acid; Tetracosahexaenoic acid CAR(10:2): Fatty Acyls; Fatty esters; CAR 10:2\
DG(33:1): Glycerolipids; Diradylglycerols

Now calculate the total number of missing values both across samples and metabolites (because the previous plots are hard to read)

```{r number of missing values across samples and metabolites}

count_miss_met <- apply(metabolites_t, 2, function(x) sum(is.na(x)))
count_miss_met <- cbind.data.frame(Count = count_miss_met, Metabolite = names(metabolites_t))
# kable(count_miss_met)

count_miss_samp <- apply(metabolites_t, 1, function(x) sum(is.na(x)))
count_miss_samp <- cbind.data.frame(Count = count_miss_samp, Sample = metabolites_t$StudyID)
# kable(count_miss_samp)

```

```{r bar chart of missing values across samples and metabolites}

ggplot(count_miss_met, aes(x = Count)) + geom_histogram() + ggtitle("Number of missing values per metabolite") +
  ylab("# of metabolites")

ggplot(count_miss_samp, aes(x = Count)) + geom_histogram() + ggtitle("Number of missing values per sample") +
  ylab("# of samples")

```

For now, let us exclude above mentioned metabolite and sample from our data

```{r removing data with very large number of missing values}

metabolites_t2 <- metabolites_t %>% dplyr::select(!miss_gtx_names) %>% filter(StudyID != "2324")

```

Now let us look at the missing data again

```{r missing data 2}

#function to calculate total number of missing values

vis_miss(metabolites_t2)

```

Let us first impute the missing values. I will just use medians of each metabolites for now

```{r imputing missing values using medians}

#Replace NAs with medians

for(i in 4:ncol(metabolites_t2)) {
  metabolites_t2[ , i][is.na(metabolites_t2[ , i])] <- median(metabolites_t2[ , i], na.rm=TRUE)
}


#Check the missing data pattern again

vis_miss(metabolites_t2)

#Plot metabolite distribution	

ggplot(metabolites_t2, aes(x = `VANILLYLMANDELIC ACID`, fill = "red")) + geom_density()	

```

Now log transform all metabolites

```{r log transformation of metabolomics data}

for(i in 4:ncol(metabolites_t2)) {
  metabolites_t2[ , i] <- log(metabolites_t2[,i])
}


#Plot metabolite distribution	
ggplot(metabolites_t2, aes(x = `VANILLYLMANDELIC ACID`, fill = "red")) + geom_density()	

```

Now plot the means again

```{r plotting the mean of metabolites again}

logmet_sum <- sumstats(metabolites_t2[,4:ncol(metabolites_t2)])

plot(logmet_sum$GeoMean, xlab = "Metabolite", ylab = "Mean", main = "Visualzing means of log-transformed metabolites")

# exp(logmet_sum$Mean)

```

Now the means of metabolites look more uniform across all samples. Let us also look at box plots for each metabolite - plot does not look very clean. Hence, I commented it out below.

```{r box plot for distirbution of metabolites}

# metabolites_t2_long <- metabolites_t2 %>% pivot_longer(cols = !c(samp, StudyID, VISITID), names_to = "Metabolites", values_to = "Conc" )
# 
# ggplot(metabolites_t2_long, aes(x = Conc, y = Metabolites, group = Metabolites)) + geom_boxplot()

```

Quantile normalization of data (across samples) - I have stopped quantile normalization for now opting to go with auto scaling since that will make data approximately normal. 

First, plot non-normalized metabolites for each sample first

```{r First plot non-normalized values}

# colramp = colorRampPalette(c(3,"white",2))(99)
# 
# plot(density(t(metabolites_t2[1,4:326])),col=colramp[1],lwd=3, ylim=c(0,0.30))
# 
# for(i in 1:99){
#   lines(density(t(metabolites_t2[i, 4:326])),lwd=3,col=colramp[i])
#   }
# 

```

We see that the distribution of metabolites for each sample is not exactly similar. We can make them all similar via quantile normalization.

Now conduct quantile normalization and replot them

```{r quantile normalization}
# 
# t_metabolites_t2 <- t(metabolites_t2[,4:326])
# id_vars_met <- metabolites_t2[,1:3]
# 
# 
# t_metabolites_t2 <- preprocessCore::normalize.quantiles(t_metabolites_t2)
# t_metabolites_t3 <- as.data.frame(t(t_metabolites_t2))
# 
# t_metabolites_t3 <- cbind.data.frame(id_vars_met, t_metabolites_t3)
# 
# names(t_metabolites_t3) <- names(metabolites_t2)
# 
# metabolites_t2 <- t_metabolites_t3
# 
#  plot(density(t(metabolites_t2[1,4:326])),col=colramp[1],lwd=3, ylim=c(0,0.30))
# 
#  for(i in 1:99){
#    lines(density(t(metabolites_t2[i, 4:326])),lwd=3,col=colramp[i])
#    }
# 
# 
# #Plot the distribution again
# 
# ggplot(metabolites_t2, aes(x = `Cer(d40:1)`, fill = "red")) + geom_density()

```

Now, we see that all plots are lined up together

Normalize metabolomics data using autoscaling. This scaling method was chosen because it makes all metabolites equal, i.e, mean = 0 and SD = 1. For more info on different normalization methods, see <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1534033/>

```{r normalization of metabolomics data}

metabolites_t2[,4:326] <- apply(metabolites_t2[,4:326], 2, function(x) (x-mean(x))/sd(x)) #Auto scaling of log-transformed data

logmet_sum_cen <- apply(metabolites_t2[,4:326], 2, mean)

plot(logmet_sum_cen, xlab = "Metabolite", ylab = "Mean", main = "Visualzing means of log-transformed/auto-scaled metabolites")


# write.csv(metabolites_t2, "processed_metabolites_file.csv")

```

The two outliers (max and min values) represent PC(36:3), however, those metabolites were not identified as significant in later analyses.

## Look at the phthalates data

I will conduct preliminary analysis of phthalates data

```{r first look at phthalates data}

#Convert phthalates data to longer form

phthalates_long <- phthalates4_wide2 %>% pivot_longer(DEHP:MCOP, names_to = "Phthalates", values_to = "Conc")


#Calculate summary statistics per pthalates

phthalates_sum <- phthalates_long %>% group_by(VISITID, Phthalates) %>% 
                  dplyr::summarize(Mean = mean(Conc, na.rm = TRUE), Median = median(Conc, na.rm = TRUE), GM = geomean(Conc))

```

Draw plots to visualize geomeans trends across visits

```{r phthalates trends across visits}

phthalates_sum_new <- phthalates_sum %>% filter(!(Phthalates %in% c("DINCH", "DEHTP", "MNP", "MONP")))	

ggplot(phthalates_sum_new, aes(x = as.numeric(VISITID), y = GM, group = Phthalates, col = Phthalates)) + geom_line() + 	
  geom_dl(aes(label = Phthalates), method = list(dl.combine("last.qp")), cex = 0.075) +	
  theme(legend.position = "none") + ggtitle("Temporal trend of Phthalates over pregnancy period") + xlab("Visit") + ylab("GM (ng/ml)") +	
  scale_x_continuous(breaks = c(1,2,3))

```

Look at the distribution of phthalates

```{r distribution of phthalates}

phthalates_long_v3 <- phthalates_long %>% filter(VISITID == 3)

phthalates_long_v3_new <- phthalates_long_v3 %>% filter(!(Phthalates %in% c("DINCH", "DEHTP", "MNP", "MONP")))	

ggplot(phthalates_long_v3_new, aes(x = Conc, fill = Phthalates)) + 	
  geom_histogram() + facet_wrap(~Phthalates, nrow = 3, scales = "free") +	
  theme(legend.position = "none") + ggtitle("Distribution of Phthalate metabolites") + 	
  xlab("GM Conc (ng/ml)") + ylab("Frequency")

```

Since the all distributions are skewed, we need to log transform phthaltaes metabolites

```{r log transformation of phthalates, cache=FALSE}

#main data

phthalates4_wide2 <- phthalates4_wide2 %>% select(StudyID, VISITID, CONCUNITS, DEHP, MBP, MIBP, MBZP, MEP, MCPP, MCNP, MCOP, sg)



# for plotting - in long format

phthalates_long <- phthalates_long %>% mutate(logConc = log(Conc))

phthalates_long_v3 <- phthalates_long_v3 %>% mutate(logConc = log(Conc))

phthalates4_wide2_v3 <- phthalates4_wide2  %>% filter(VISITID == 3)

```

I will now draw histograms using log-transformed phthalates metabolites

```{r distribution of log transformed phthalates}

ggplot(phthalates_long_v3, aes(x = logConc, fill = Phthalates)) + 
  geom_histogram() + facet_wrap(~Phthalates, nrow = 4, scales = "free") +
  theme(legend.position = "none") + ggtitle("Distribution of Log-transformed Phthalates metabolites (VISITID = 3)") + 
  xlab("logConc (ng/ml)") + ylab("Frequency")


```

Note: I removed following phthalates from the dataset in analytic_file_creation_62122: MHBP, MHIBP, MNP, DINCH, DEHTP, MONP,  DBP, DIBP. They were removed because they had more than 30% missing data. 

Previous comment: The distributions for MNP, MONP, and DEHTP look scattered. This may be due to many missing values for phthalates metabolites.

```{r missing values for phthalates}

# count_miss_phthalates <- apply(phthalates4_wide2_v3[, c(1,4:19)], 2, function(x) sum(is.na(x)))


count_miss_phthalates <- apply(phthalates4_wide2_v3[, c(1,4:11)], 2, function(x) sum(is.na(x)))
count_miss_phthalates <- as.data.frame(count_miss_phthalates)
count_miss_phthalates <- cbind.data.frame(count_miss_phthalates, Phthalates = rownames(count_miss_phthalates)) %>% filter(Phthalates != "StudyID")

ggplot(count_miss_phthalates, aes(y = Phthalates, x = count_miss_phthalates, fill = Phthalates)) + 
  geom_bar(stat = "identity") + theme(legend.position = "none") + xlab("Number of Missing values") + ylab("Phthalates") +
  ggtitle("Number of missing values for each Phthalate metabolite or parent") 

vis_miss(phthalates4_wide2_v3[, c(1,4:11)], cluster = TRUE) + theme(plot.margin = margin(0,50,0,0))

# vis_miss(phthalates4_wide2_v3[, c(1,4:19)], cluster = TRUE) + theme(plot.margin = margin(0,50,0,0))

```

All of the following is previous commentary. I have decided to remove these phthalates in the analytic data creation phase. 

As expected, we are missing significant number of values for DINCH, DEHTP, MNP, and MONP. We know from analytic file creation that MHINCH, MNP, MCOCH, and MEHP have more than 20% of values below the LOD. For example, MHINCH: 59%; MNP: 41%; MCOCH: 40%; MEHP: 21%

Since DINCH is a combination of MCOCH and MHINCH and has 15.1% of missing values with 59% and 40% of values under LOD for MHINCH and MCOCH, respectively, we will exclude it from analysis for now. Similarly, MNP has missing values for 47% of samples and for 41% of samples, the values are below LOD. For DEHP, which includes MEHP, there are no missing values.

Based on the above information, I will exclude DINCH, DEHTP, MNP, and MONP from analysis for now.

Now let us average phthalate values over 3 visits and see if there are still missing values.

```{r averaging phthalate values over 3 visits}


phthalates4_wide2_avg <- phthalates4_wide2 %>% group_by(StudyID) %>% summarise(DEHP_gm = (geomean(DEHP)),
                                                                            # DBP_gm = (geomean(DBP)),
                                                                            # DIBP_gm = (geomean(DIBP)),
                                                                            # DINCH_gm = (geomean(DINCH)),
                                                                            # DEHTP_gm = (geomean(DEHTP)),
                                                                            MBP_gm = (geomean(MBP)),
                                                                            MIBP_gm = (geomean(MIBP)),
                                                                            MBZP_gm = (geomean(MBZP)),
                                                                            MEP_gm = (geomean(MEP)),
                                                                            MCPP_gm = (geomean(MCPP)),
                                                                            MCNP_gm = (geomean(MCNP)),
                                                                            # MNP_gm = (geomean(MNP)),
                                                                            MCOP_gm = (geomean(MCOP))
                                                                            # MONP_gm = (geomean(MONP))) %>%
                                                                            # MEHP_gm = (geomean(MEHP)),
                                                                            # MEHHP_gm = (geomean(MEHHP)),
                                                                            # MEOHP_gm = (geomean(MEOHP)),
                                                                            # MECPP_gm = (geomean(MECPP)))
                                                                            )%>% 
  select(StudyID, contains("gm"))


sg_avg <- phthalates4_wide2 %>% group_by(StudyID) %>% summarise(sg_gm = exp(mean(log(sg)))) %>% select(StudyID, sg_gm)

vis_miss(phthalates4_wide2_avg, cluster = TRUE) + theme(plot.margin = margin(0,50,0,0))

```


Now log-transform the pthalate concentrations 

```{r log transform phthalate concs}

# for(i in 4:19) {

for(i in 2:9) {
  phthalates4_wide2_avg[ , i] <- log(phthalates4_wide2_avg[,i])
}


```




So, we will use phthalates concentrations averaged over 3 visits

```{r set phthalates4_wide2_avg as the phthalates analytic data}

phthalates4_wide2_v3 <- phthalates4_wide2_avg

# oldnames <- c("DEHP_gm", "DBP_gm", "DIBP_gm", "DINCH_gm", "DEHTP_gm", "MBZP_gm", "MEP_gm", "MCPP_gm",  "MCNP_gm", "MNP_gm", "MCOP_gm", "MONP_gm")
# newnames <- c("DEHP", "DBP", "DIBP", "DINCH", "DEHTP", "MBZP", "MEP", "MCPP", "MCNP", "MNP", "MCOP", "MONP")
# 
# phthalates4_wide2_v3 <- phthalates4_wide2_v3 %>% rename_at(vars(oldnames), ~ newnames)


phthalates4_wide2_v3 <- phthalates4_wide2_v3 %>% rename_at(vars(ends_with("gm")), funs(stringr::str_replace(., "_gm", "")))

```

Exclude DINCH, DEHTP, MNP, and MONP from analysis for now. - not needed because I already removed them in the analytical data creation phase. 

```{r remove DINCH, DEHTP, MNP, and MONP from analysis}

phthalates4_wide2_v3_b <- phthalates4_wide2_v3 

# phthalates4_wide2_v3 <- phthalates4_wide2_v3 %>% select(!c(DINCH, DEHTP, MNP, MONP))

```

Let us look at correlation between different phthalate metabolites

```{r correlation between different phthalates}

# phcor <- cor(phthalates4_wide2_v3[,4:11], method = c("spearman"), use = "complete.obs") #while using only v3 data

phcor <- cor(phthalates4_wide2_v3[,2:9], method = c("spearman"), use = "complete.obs")


ggcorrplot(phcor, hc.order = TRUE, 
           type = "lower",
           lab = TRUE)

```

It looks like DBP vs DIBP, MCPP vs MCOP, DEHP vs DBP are highly correlated.

Now, I will look at correlations between individual phthalate metabolite and metabolomics data

Combine phthalates data with metabolomics data and get rid of Concunits column

```{r combine phthalates data with metabolomics data}

# phthalates_met2 <- metabolites_t2 %>% inner_join(phthalates4_wide2_v3, by = c("StudyID", "VISITID")) %>% select(!c(CONCUNITS)) # while using only v3 data

phthalates_met2 <- metabolites_t2 %>% inner_join(phthalates4_wide2_v3, by = c("StudyID"))

phthalates_met2_b <- metabolites_t2 %>% inner_join(phthalates4_wide2_v3_b, by = c("StudyID"))


```

Then, calculate correlation coefficients

```{r correlation coefficients between phthalates and metabolites}

cor1 <- matrix(0, nrow = 323, ncol = 8)

for (i in 4:326)
  for (j in 327:334){
  cor1[i-3,j-330] <- cor(phthalates_met2[,j], phthalates_met2[,i], method = c("spearman"), use = "na.or.complete")
  
  }

cor1 <- as.data.frame(cor1)

colnames(cor1) <- names(phthalates_met2[,327:334])
cor1 <- cbind.data.frame(cor1, samp = names(phthalates_met2[,4:326]))
  
# cor1[cor1>0.25]  

```

Now look for metabolites with correlation coefficient \> .3

```{r selecting metabolites with r gt 0.3}

rthres <- 0.3
cor2 <- cor1 %>% filter(abs(DEHP) > rthres|abs(MBP) > rthres|abs(MIBP) > rthres|abs(MBZP) > rthres|abs(MEP) > rthres|abs(MCPP) > rthres|
                          abs(MCNP) > rthres|abs(MCOP) > rthres)

# | abs(MEHP > rthres| abs(MEOHP) > rthres| abs(MECPP) > rthres| abs(MEHHP) > rthres

rownames(cor2) <- cor2$samp
cor2 <- cor2 %>% select(!samp)
cor2_mat <- as.matrix(cor2)

# heatmap(as.matrix(cor2), Colv = NA, Rowv = NA)
# heatmap.2(as.matrix(cor2), dendrogram = 'none', density = "none", trace = "none")

ComplexHeatmap::Heatmap(cor2_mat, row_names_side = "left", row_names_gp = grid::gpar(fontsize = 6)) 


```

We see from the above figure that some log-transformed metabolites are averagely correlated with log-transformed phthalates. Now, let us create univariate linear models between individual phthalates and metabolites.

Since I initially standardized phthalates by Sg, I need to unstandardize them first and then include Sg in the model, which has been the practice in the Meeker Lab.

Add sg to the phthalates_met2

Added on 1/16/2023: to be consistent with cord blood data, I am using sg corrected phthalates in models going forward. 

```{r adding sg to phthalates_met2}

phthalates_met2 <- phthalates_met2 %>% inner_join(sg_avg, by = c("StudyID"))  %>% dplyr::rename(sg = sg_gm)#comment out while only working with v3 data

```

```{r unstandarize the phthalates values}

#Unstandarize in two steps: First obtain P value: P = exp(Pc)*(Sg-1)/(1.019-1), and second, log-transform it

#first step
# 
# for(i in 327:334) {
#   phthalates_met2[ , i] <- (exp(phthalates_met2[ , i]))*(phthalates_met2$sg-1)/(1.019-1) #Equation from Rodriguez-Carmona et al. 
# }
# 
# 
# #Second step
# 
# for(i in 327:334) {
#   phthalates_met2[ , i] <- log(phthalates_met2[ , i])
# }



```

Now run multiple linear regression models 

The covariates I initially want to use are:

Zhang et al., 2021: Atlanta AA Maternal-Child cohort:

Age, BMI, Education, Parity, Tobacoo, Alcohol, Marijuana, Insurance Type, Baby Sex, Gestational Age

Zhou et al., 2018: Center for the Health Assessment of Mothers and Children of Salinas (CHAMACOS):

Parity, BMI

Aung et al., 2021: LIFECODES cohort

Age, Race, Insurance provider (public/private), Education, BMI, Alcohol, Tobacoo, Fetal Sex

Based on my conversation with Deb, we will use maternal age and prepregnancy BMI as covariates for now.

Deb uploaded new covariates file in 09/22, so let me look at that file and make sure some covariates match

```{r comparing new and old covariates file}

covars_new <- readxl::read_excel("covars_92622.xlsx", sheet = "Sheet1") %>% select(PROTECTID, isage, PPSEX)	
names(covars_new) <- c("StudyID", "isage", "PPSEX")	
covars_new$StudyID <- as.character(covars_new$StudyID)	
covars_chk <- covars %>% inner_join(covars_new, by = "StudyID") %>% mutate(agechk = isage.x - isage.y)	

ppsex_dat <- covars_new %>% select(StudyID,  PPSEX) #1 is female and 0 is male


```

Age match for all participants, so I think we are good to go with the older file for now.

Merge covariates with phthalates_met2

```{r adding covariates to phthalates_met2 data}

phthalates_met2_missing <- phthalates_met2 %>% anti_join(covars, by = c("StudyID"))

phthalates_met2 <- phthalates_met2 %>% inner_join(covars, by = c("StudyID"))
phthalates_met2 <- phthalates_met2 %>% left_join(ppsex_dat, by = c("StudyID"))



```

Check for missing values in the covariates

```{r missing values for covariates}

vis_miss(phthalates_met2[,335:348])

```


We do not have any missing values for age, but do have some missing values for BMI. I will impute those missing values using median

```{r imputing missing values for covariates}

#Using impute function from Hsmic package. It does the same job as the code I have above

phthalates_met2$prebmi <- with(phthalates_met2, impute(prebmi, median))

vis_miss(phthalates_met2[,335:348]) + theme(plot.margin = margin(0,50,0,0))

phthalates_met2$prebmi <- as.numeric(phthalates_met2$prebmi)


save(phthalates_met2, file = "phthalates_met2.RData")


```

Let us check the distribution of two covariates.

```{r testing checking for covariates transformation}

par(mfrow = c(1,2))

hist(phthalates_met2$isage,  main = "Histogram of age") 
hist(phthalates_met2$prebmi,  main = "Histogram of BMI")
```


```{r linear modeling with covariates}

fit_lin3 <- matrix(0, nrow = 323, ncol = 8)
fit_lin4 <- matrix(0, nrow = 323, ncol = 8)

phthalates_met2[, 327:334] <- scale(phthalates_met2[,327:334]) #scaling does not change the final results



for (i in 4:326)
  for (j in 327:334){

  # fit_lin3[i-3,j-330] <- summary(lm(phthalates_met2[,i] ~ phthalates_met2[, j] + sg + isage + prebmi, data = phthalates_met2))$coefficients[17] #p value
  # 
  # fit_lin4[i-3,j-330] <- summary(lm(phthalates_met2[,i] ~ phthalates_met2[, j] + sg + isage  + prebmi, data = phthalates_met2))$coefficients[2] #beta
    
  fit_lin3[i-3,j-326] <- summary(lm(phthalates_met2[,i] ~ phthalates_met2[, j] +isage + prebmi, data = phthalates_met2))$coefficients[14] #p value

  fit_lin4[i-3,j-326] <- summary(lm(phthalates_met2[,i] ~ phthalates_met2[, j] + isage  + prebmi, data = phthalates_met2))$coefficients[2] #beta

  }


fit_lin3 <- as.data.frame(fit_lin3)
fit_lin4 <- as.data.frame(fit_lin4)
# fit_lin3 <- as.data.frame(fit_lin3)

colnames(fit_lin3) <- names(phthalates_met2[,327:334])
colnames(fit_lin4) <- names(phthalates_met2[,327:334])

fit_lin3 <- cbind.data.frame(fit_lin3, samp = names(phthalates_met2[,4:326]))
fit_lin4 <- cbind.data.frame(fit_lin4, samp = names(phthalates_met2[,4:326]))


```

Now, I will derive FDR adjusted p-values again. Using Q value approach would result in same conclusions regarding the significant metabolites.

```{r checking for significant metabolites after adding covariates}

#Define FDR threshold value

pthres = 0.05

fit_lin3_adjust <- cbind.data.frame(samp = fit_lin3[,9], 
                                    apply(fit_lin3[,1:8], 2, function(x) p.adjust(x, method = "BH")))

fit_lin3_adjust_long <- fit_lin3_adjust %>% pivot_longer(!samp, names_to = "Phthalates", values_to = "adj_p") %>% 
                        mutate(pval_ind = ifelse(adj_p > pthres, 0, 1))

fit_lin4_adjust_long <- fit_lin4 %>% pivot_longer(!samp, names_to = "Phthalates", values_to = "betas") 

fit_lin34_adjust_long <- cbind.data.frame(fit_lin3_adjust_long, betas = fit_lin4_adjust_long$betas)
fit_lin34_adjust_long <- fit_lin34_adjust_long %>% mutate(beta_sign = ifelse(betas < 0, "Negative", "Positive"))

```

Now draw a Manhattan plot of p-values

```{r manhattan plot of p-values after adding covariates}

group.colors <- c(Negative = "skyblue4", Positive = "tomato1")

	
fit_lin34_adjust_long <- fit_lin34_adjust_long %>% mutate(`Beta coefficient` = beta_sign, Label = ifelse(adj_p < 0.05, "1", ""))	
fit_lin34_adjust_long2 <- fit_lin34_adjust_long %>% filter(adj_p <= 0.05)
fit_lin34_adjust_long2$`Beta coefficient` <- factor(fit_lin34_adjust_long2$`Beta coefficient`, levels = c("Negative", "Positive"))


man_plot2 <- ggplot(fit_lin34_adjust_long, aes(x = samp, y = -log10(adj_p), color = `Beta coefficient`)) + 	
            geom_point(shape = 15) + 	
            theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank(),	
                  panel.background = element_rect(fill = 'white'),	
                  strip.background = element_rect(fill = 'white'), strip.placement = "outside", axis.line = element_line(),	
                  legend.position = "bottom") +	
                  scale_y_continuous(expression(paste(-log10('p-value')))) +	
                  # scale_color_discrete("Beta coefficient") +	
                  facet_wrap(~Phthalates, strip.position = "bottom", nrow = 1) 	

man_plot2 <- man_plot2  + theme(panel.spacing.x = unit(0, "cm")) +	
  geom_hline(yintercept = -log10(0.05), col = "red", linetype = 2) +	
  # geom_hline(yintercept = -log10(0.05), col = "green", linetype = 2) +	
  # ggtitle("Figure 1. Adjusted p-values from MWAS analysis for each phthalate \nmetabolite and metabolic marker") 	+
  scale_fill_manual(values = group.colors)
  #geom_text(data = fit_lin34_adjust_long2, aes(label = samp), hjust = -0.1, vjust = 0, size = 3 )

man_plot2

```

Now, I will tabulate and plot only the significant metabolites

```{r choosing only significant metabolites after adding covariates}


all_sig2 <- fit_lin34_adjust_long %>% filter(adj_p < pthres) %>% arrange(Phthalates, adj_p) %>% select(samp, Phthalates, adj_p, betas, beta_sign) %>% 
            rename("Metabolites" = "samp")

sig_4pth <- all_sig2 %>% filter(Phthalates == "DBP"|Phthalates == "DIBP"|Phthalates == "MCNP"|Phthalates == "MCOP") 

sig_dehp <- all_sig2 %>% filter(Phthalates == "DEHP") 

sig_mcpp <- all_sig2 %>% filter(Phthalates == "MCPP") 

# all_sig2 %>% group_by(Phthalates) %>% dplyr::summarize(Nsig = n())

ggplot(all_sig2, aes(x = Phthalates, group = Phthalates, fill = Phthalates)) + geom_bar() + theme(legend.position = "none", axis.title.x  = element_blank()) + ggtitle("Number of significant metabolic markers per phthalate metabolite")  + facet_wrap(~beta_sign)

write.csv(all_sig2, file = "C:/Users/rsiwa/OneDrive/Michigan_course/research_rotation2/manuscript_writing/significant_metabolites_by_phthalates.csv")

```

Now let us look at betas vs p-values

```{r betas vs. p values for significantly associated phthalates}

mcpp_toplot <- fit_lin34_adjust_long %>% filter(Phthalates == "MCPP") 

ggplot(aes(x = (2^betas), y = -log10(adj_p)), data = mcpp_toplot) +
  geom_point()


```






Plot significant metabolites using a heat plot. Here, I am only plotting metabolites with adjusted p-values \< 0.1 to make it easier to visuaulize the result.

```{r plotting significant metabolites}

pthres2 <- 0.05
my_palette <- colorRampPalette(c("blue", "white", "red"))(n = 50)
	
all_sig2_plot <- all_sig2 %>% filter(adj_p < pthres2) %>% mutate(`Beta coefficient` = betas)	

hmap1 <- ggplot(all_sig2_plot, aes(Phthalates, Metabolites, fill = `Beta coefficient`, label = round(adj_p,2))) + geom_tile() +	
  # geom_text() +	
  theme_classic() +	
  scale_x_discrete(expand=c(0,0)) +	
  scale_y_discrete(expand=c(0,0), position = "right") +	
  theme(axis.text.y = element_text(size = 6, vjust = 0.1, ), legend.position = "bottom", axis.title.y = element_blank(),
        axis.ticks.y = element_blank(), axis.title.x = element_blank()) +	
  ggtitle("Heatmap of metabolites significantly associated with prenatal phthalates") + 	
  labs(color = "Beta coefficient") +	
  scale_fill_distiller(palette = "Spectral")  + scale_color_gradient2(low = "blue", high = "red", mid = "white") 

hmap1


#Another way


# Create the heatmap
all_sig2_plot <- all_sig2_plot %>% rename("Beta sign" = "beta_sign") %>%
  mutate(Metabolites2 = case_when(Metabolites == "AMINO FATTY ACIDS (C8H17NO2)" ~ "2-Aminooctanoic acid",
                                 Metabolites == "DICARBOXYLIC ACIDS (C16H30O4)" ~ "Hexadecanedioic acid",
                                 Metabolites == "DICARBOXYLIC ACIDS (C12H22O4)" ~ "Dodecanedioic acid",
                                 Metabolites == "DICARBOXYLIC ACIDS (C18H32O4)" ~ "Octadecenedioic acid",
                                Metabolites == "FA(18:1(Ke)).1" ~ "FA(18:1(Ke))"))

all_sig2_plot <- all_sig2_plot %>% mutate(Metabolites = ifelse(is.na(Metabolites2), Metabolites, Metabolites2)) %>%
  mutate(Metabolites = toupper(Metabolites))
         
  

ggplot(all_sig2_plot, aes(Phthalates, Metabolites, fill = `Beta coefficient`)) +
  geom_tile() +
  scale_fill_gradient2(low = "red", high = "blue", mid = "white", 
                       midpoint = 0, limit = c(-0.5,0.5), 
                       name = "Beta coefficient") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1), legend.position = "bottom") +
  labs(x = "Phthalates", y = "Plasma metabolic features")

```




Now lets see how many phthalates each significant metabolite is associated with

```{r counting the number of times each metabolite is associated with}

sum_all_sig2 <- all_sig2 %>% group_by(Metabolites) %>% summarise(NumPhthalates = n()) %>% arrange(desc(NumPhthalates))
kable(sum_all_sig2)

# write.csv(sum_all_sig2, file = "significant_metabolites.csv")
 
```

Since Cer(d40:1) is linked with the most phthalates, I will draw scatter plots for it

```{r scatterplots for ceramide}

cer <- phthalates_met2 %>% select(StudyID, `Cer(d40:1)`, DBP, DEHP, DIBP, MCNP, MCOP, MCPP)
cer_long <- cer %>% pivot_longer(cols = DBP:MCPP, names_to = "Phthalates", values_to = "LogConc")

ggplot(cer_long, aes(x = LogConc, y = `Cer(d40:1)`, color = Phthalates)) + geom_point() + geom_smooth(method = "lm") +
  facet_wrap(~Phthalates, scales = "free") + theme(legend.position = "none") + 
  ggtitle("Urinary Phthalates and Cer(d40:1)") + xlab("Phthalates") 

```

Check why arachidonic acid is no longer included in the list of significant metabolites

```{r arachidonic acid}

fit_lin34_adjust_long %>% filter(samp == "ARACHIDONIC ACID") 

```

Note: I have removed 4 monoesters of DEHP from analysis for now. 



###Add classes of significant metabolites

Now, I will add classes of these significant metabolites.

```{r adding classes for significant metabolites}

all_sig2$Metabolites <- trimws(all_sig2$Metabolites, which = c("both"))
all_sig2$Metabolites <- toupper(all_sig2$Metabolites)


all_sig2_class <- all_sig2 %>% left_join(classes, by = c("Metabolites"))

all_sig2_class2 <- all_sig2_class %>% filter(adj_p < 0.05)

all_sig2_class3 <- all_sig2_class2 %>% select(Metabolites, Phthalates, beta_sign, Class_new2)
all_sig2_class3_wide <- pivot_wider(all_sig2_class3, names_from = Phthalates, values_from = beta_sign)

# write.csv(all_sig2_class2, "significant_metabolites_with_class_92622.csv")
# write.csv(all_sig2_class3_wide, "significant_metabolites_with_class_wide.csv")


```


Now create a plot showing metabolites classes vs. phthalates

```{r plotting metabolite classes vs. phthalates}

all_sig2_class2 <- all_sig2_class2 %>% mutate(`Beta coefficient` = beta_sign)
all_sig2_class2$`Beta coefficient` <- factor(all_sig2_class2$`Beta coefficient`, levels = c("Negative", "Positive"))


all_sig2_class2_nodbp <- all_sig2_class2 %>% filter(Phthalates != "DBP")


all_sig2_class2_nodbp <- all_sig2_class2_nodbp %>% 
  mutate(Metabolites2 = case_when(Metabolites == "AMINO FATTY ACIDS (C8H17NO2)" ~ "2-Aminooctanoic acid",
                                 Metabolites == "DICARBOXYLIC ACIDS (C16H30O4)" ~ "Hexadecanedioic acid",
                                 Metabolites == "DICARBOXYLIC ACIDS (C12H22O4)" ~ "Dodecanedioic acid",
                                 Metabolites == "DICARBOXYLIC ACIDS (C18H32O4)" ~ "Octadecenedioic acid",
                                Metabolites == "FA(18:1(Ke)).1" ~ "FA(18:1(Ke))"))


all_sig2_class2_nodbp <- all_sig2_class2_nodbp %>% mutate(Metabolites = ifelse(is.na(Metabolites2), Metabolites, Metabolites2)) %>%
  mutate(Metabolites = toupper(Metabolites))
         

classplot1 <- ggplot(all_sig2_class2_nodbp, aes(y = Class_new2,  fill = `Beta coefficient`)) + geom_bar() + theme_classic() +
  facet_grid(~Phthalates, scales = "free_y") + theme(legend.position = "none", axis.title.y = element_blank(),
                                                     strip.background = element_rect(fill = 'white', linetype = 0), strip.placement = "outside", axis.line = element_line(), panel.spacing.x = unit(0, "cm"), axis.ticks.y = element_blank())  +
  # ggtitle("Figure 1. Class distribution of significantly associated metabolic markers from MWAS") +
  xlab("Count")  + 
  scale_fill_manual(values = group.colors)

classplot1

```

Now that we have conducted univariate analyses and have a list of significant metabolites, we can start working on multivariate models. First use hierarchial clustering of metabolites. I will only include significant metabolites

###Hierarchial clustering

Now let us focus on creating clusters of metabolic markers based on the threshold of number of metabolic markers below r = 0.2 and the minimum number of markers in each cluster.

Note added on 8/4/23: Before I simply used dist(cor_met_sp) as the distance matrix. HOwever, upon further reading of how hierchical clustering works (uses dissimilarity matrix, i.e., a value of 0 is considered as being v v close), I am changing the correlation matrix to distance matrix using as.dist(1-cor_met_sp). 

```{r hierarchial clustering of metabolic markers}

#Create correlation matrix

mets_forCor <- phthalates_met2[, 4:326]
cor_met <- rcorr(as.matrix(mets_forCor), type="spearman")
cor_met_sp <- cor_met$r
cor_met_sp2 = 1-cor_met_sp

#Hierarchial clustering

my_palette <- colorRampPalette(c("blue", "white", "red"))(n = 50)
# heatmap.2(cor_met_sp, dendrogram="col",  density.info="none", trace="none",
#           main="Metabolite Correlations", margins =c(12,9), col=my_palette)


#Function to create a cluster

getclus <- function(x, data){
  hc.rows <- hclust((data), method = "average")
  ct <- cutree(hc.rows, h=x)  # cut the dendrogram into clusters
  plot(hc.rows,hang = -1, cex = 0.6) #plot dendrogram
  dend <- rect.hclust(hc.rows, h = x) # visualize the groups
  sum_ct <- table(ct)
  return(list(dend, ct, sum_ct))
}

#Mean correlation per cluster 

get_mean <- function(clus){
  mean_all <- NULL
  for(i in 1: length(clus[[1]])){
   # gp <- names(clus[[1]][[i]])
    gp <- names(which(clus[[2]]==i))
    gp_cor <-cor_met_sp[which(rownames(cor_met_sp) %in% gp ==TRUE),which(colnames(cor_met_sp) %in% gp ==TRUE)]
    cor_mean <- mean(gp_cor[lower.tri(gp_cor)],na.rm=TRUE)
    row=data.frame(group=i, num=length(gp),cor_mean=round(cor_mean,3))
    mean_all <- rbind(mean_all, row)
  }
  return(mean_all)
}

```

Let us also form the cluster of significantly associated metabolites 

```{r hierachial clustering of significantly associated metabolites}

names(phthalates_met2) <- toupper(names(phthalates_met2))

sigmet_singpol <- phthalates_met2 %>% select(any_of(all_sig2_class3_wide$Metabolites))

# setdiff(all_sig2_class3_wide$Metabolites, names(phthalates_met2[,4:326]))

sigmets_cor <- rcorr(as.matrix(sigmet_singpol), type = "spearman")
sigmets_cor2 <- sigmets_cor$r
# plot(hclust(dist(sigmets_cor2)), hang = -1, cex = 0.6)

clus1 <- getclus(1, data = as.dist(1-sigmets_cor2))
clus1_mean <- get_mean(clus1)


```


#For different values of h, plot numbers of clusters with average r < 0.15 vs. n < 5

```{r clustering for all metabolites}

seqval <- seq(0.5,3, 0.05)
matval <- matrix(nrow = length(seqval), ncol = 4)
# corchk_temp <- vector(nro)


for (i in seqval){
  optclus_temp <- getclus(x=i, data = as.dist(cor_met_sp2))
  optclus_mean_temp <- get_mean(optclus_temp)
  pos <- match(i, seqval)
  matval[pos, 1] <- i
  matval[pos, 2] <- length(which(optclus_mean_temp$cor_mean < .3)) #number of clusters with avg r mean lt 0.3
  matval[pos, 3] <- length(which(optclus_mean_temp$num < 5)) #number of clusters with <5 metabolic markers
  matval[pos, 4] <- length(optclus_temp[[3]]) #number of clusters
  
}


```


Let us check what would be the optimal length to use

```{r checking the optimal length of a cluster}


matval <- as.data.frame(matval)
names(matval) <- c("len", "n_rlt2", "n_nlth5", "n_clus")

matval_n <- matval %>% select(len, n_nlth5, n_clus) %>% mutate(Criteria = "ClusSize >= 5")
names(matval_n) <- c("length", "n_clus_bad", "n_cluster", "Criteria") #n_clus_bad = clusters not meeting the requirement
matval_r <- matval %>% select(len, n_rlt2, n_clus) %>% mutate(Criteria = "Pairwise_r >= 0.2")
names(matval_r) <- c("length", "n_clus_bad", "n_cluster", "Criteria") 

matval_long <- rbind.data.frame(matval_n, matval_r)


ggplot(matval_long, aes(x = length, y = n_clus_bad, col = Criteria)) + geom_point()
# ggplot(matval, aes(x = len, y = n_nlth5)) + geom_point()

#Also use elbow method 


plot(matval$n_clus, matval$len)

```

We see that at length = 4.75, we have 4 clusters with average r < 0.15 and 1 cluster with less than 5 metabolic markers, resulting in 13 unique clusters. I will keep use that for now. Let us run hierarchial clustering with that length.

```{r hierarchial clustering with length = 4.75}

#Get clusters with at least 5 metabolites and r < 0.15
set.seed(1991)
cluslen <- 0.75
# chk <- dist(cor_met_sp)
# optclus <- getclus(cluslen, data = chk)
# optclus_mean <- get_mean(optclus)
optclus <- getclus(cluslen, data = as.dist(cor_met_sp2))
optclus_mean <- get_mean(optclus)

corchk <- which(optclus_mean$cor_mean <0.3)
sizechk <- which(optclus_mean$num <5)

# 
# clus4.75 <- hclust(dist(cor_met_sp))
# clus4.75_cut <- cutree(clus4.75, h = 4.75)
metabolites_t3 <- phthalates_met2[,c(2,4:326)]
t_metabolites_t3 <- data.table::transpose(metabolites_t3)
rownames(t_metabolites_t3) <- colnames(metabolites_t3)
colnames(t_metabolites_t3) <- t_metabolites_t3[1,]
t_metabolites_t4 <- t_metabolites_t3[-1,]
t_metabolites_t4 <- t_metabolites_t4 %>% mutate(metabolite = rownames(t_metabolites_t4), Cluslabel = optclus[[2]]) %>% 
  select(metabolite, Cluslabel, everything())

# chk <- t_metabolites_t4 %>% select(metabolite, Cluslabel)


```


###Multivariate regression using the cluster memberships

Following Margaret's code

```{r running multivariate regression model}

clusterid <- t_metabolites_t4$Cluslabel
clustersum <- aggregate(rep(1,nrow(t_metabolites_t4)) ~ clusterid, FUN = sum)

clus_chk1 <- t_metabolites_t4 %>% select(metabolite, Cluslabel)


ttmetabolites_t4 <- as.data.frame(t(t_metabolites_t4))
ttmetabolites_t5 <- ttmetabolites_t4[3:nrow(ttmetabolites_t4),]

clustertouse <- optclus_mean %>% filter(num >=5, cor_mean >= 0.3)

row_all2 <- NULL

for (j in 327:334){
  z = data.frame(Phth=phthalates_met2[,j] , AGE = phthalates_met2$isage, BMI=phthalates_met2$prebmi)
  zz = data.matrix(z)

  for(i in clustertouse[,1]){
    ik = i
    x = ttmetabolites_t5[, clusterid == ik]
    xx = x
    xxd = data.frame(xx)
    pp = ncol(xxd)
    names(xxd) = c(paste0("M", 1:pp))

    data1 = data.frame(Phth = zz[,1], AGE = scale(zz[,2]), BMI=scale(zz[,3]), xxd)
    yvec <- as.numeric(as.matrix(cbind(data1[,4:ncol(data1)])))
    yvec <- matrix(yvec, ncol = ncol(data1)-3)
    xvec <- as.matrix(cbind(data1[,1:3]))
    my.model <- lm(yvec ~ xvec) 
    
    xvec2 <- as.matrix(cbind(data1[,2:3]))
    mlm2 <- lm(yvec ~ xvec2)
    pval <- as.numeric(anova(my.model, mlm2)$'Pr(>F)'[2])

    row <- cbind(Metab_Cluster=ik, Phthalate = colnames(phthalates_met2[j]),pval = pval, cluster_size = pp)

    row_all2 <- rbind(row_all2, row)
    # row_all2 <- as.data.frame(row_all2) %>% filter(pval < 0.05)
  }
}


```

Now look at the phthalate metabolites that were significant after adjusting for multiple testing.

```{r apply bonferroni correction}

row_all2_bhcor <- data.frame(row_all2) %>% 
  mutate(pval = as.numeric(as.character(pval))) %>% 
  group_by(Phthalate) %>% 
  mutate(BH = p.adjust(pval, method = "BH")) %>% 
 filter(BH <= 0.05)
  # dplyr::mutate(q = qvalue(pval)$qvalues)  # Not enough tests per phthalate for qvalue

row_all2_bhcor %>% arrange(Metab_Cluster)

```

Now, add class label to significantly associated metabolites

```{r adding classes to significantly associated metabolites and clusters}

row_all2_bhcor_sum <- row_all2_bhcor %>% group_by(Metab_Cluster) %>% tally() 

met_clus <- t_metabolites_t4 %>% select(metabolite, Cluslabel) %>% dplyr::rename("Metab_Cluster" = Cluslabel, "Metabolites" = metabolite) %>%
  mutate(Metab_Cluster = as.character(Metab_Cluster))

met_clus <- met_clus %>% mutate(Metabolites = toupper(Metabolites))


met_clus2 <- met_clus %>% inner_join(row_all2_bhcor_sum, by = "Metab_Cluster")
met_clus2 <- met_clus2 %>% left_join(classes, by = c("Metabolites"))

# write.csv(met_clus2, "significant_cluster_metabolites_list.csv")



```

Check the correlation structure for each clusters

```{r checking the correlation structure or each cluster}

# Split the data frame into a list of data frames
list_of_dfs <- split(met_clus2, met_clus2$Metab_Cluster)


# Initialize a list to store the correlation matrices
cor_matrices <- list()

# Loop over each data frame in the list
for(i in seq_along(list_of_dfs)) {
  # Get the metabolites for the current cluster
  metabolites <- list_of_dfs[[i]]$Metabolites
  
  # Subset phthalates_met2 to include only the columns corresponding to the metabolites
  subset <- phthalates_met2[, metabolites]
  
  # Create a correlation matrix for the subset and store it in the list
  cor_matrices[[i]] <- cor(subset, use = "complete.obs")
  
  # Plot the correlation matrix
  corrplot(cor_matrices[[i]], method = "color")
}



```


Let us look at what cluster has the highest number of signficant associations 


```{r cluster with the highest number of significant associations}

row_all2_bhcor_sum %>% arrange(desc(n))

```

Cluster 10 is associated with 5 phthalate metabolite whereas cluster 13 is associated with 4, Lets stratify clusters by classes of metabolites. 

```{r stratification of clusters by metabolites}

met_clus2 %>% group_by(Metab_Cluster, Class_new2) %>% tally() %>% arrange(Metab_Cluster, desc(n))


# phthalates_met2[,which(clusterid == 10)]


ggplot(data = met_clus2, aes(y = Class_new2, fill = Class_new2)) + geom_bar() + facet_wrap(~as.factor(Metab_Cluster), nrow = 2) + theme(legend.position = "none", axis.text.y = element_text(size = 7))


```


Looks like Cluster 1 is majorly populated by dicarboxylic acids and medium chain fatty acids whereas Cluster 10 is populated by mostly phospholipids. 

Now combine results from cluster and single pollutant analysis 

```{r combining results from cluster and single pollutant analysis}

#Get rid of duplicate metabolites

met_clus2 <- met_clus2 %>% filter(substr(Metabolites, nchar(Metabolites), nchar(Metabolites)) != 1)

met_clus2b <- met_clus2 %>% select(Metabolites, Metab_Cluster, n, Class_new2)
all_sig2_class2b <- all_sig2_class2 %>% select(Metabolites, Phthalates, adj_p, beta_sign)
fit_lin34_adjust_longb <- fit_lin34_adjust_long %>% select(samp, Phthalates, adj_p, beta_sign, pval_ind)
fit_lin34_adjust_longb <- fit_lin34_adjust_longb %>% rename("Metabolites" = "samp") %>% 
  mutate(sig_sign = paste(pval_ind, beta_sign, sep = "_")) %>% select(-adj_p, -beta_sign, -pval_ind)
fit_lin34_adjust_longb_wide <- pivot_wider(fit_lin34_adjust_longb, names_from = Phthalates, values_from = sig_sign) %>%
  mutate(Metabolites = toupper(Metabolites))

#Get rid of duplicate metabolites

fit_lin34_adjust_longb_wide <- fit_lin34_adjust_longb_wide %>% filter(substr(Metabolites, nchar(Metabolites), nchar(Metabolites)) != 1)


# row_all2_bhcor <- row_all2_bhcor %>% rename("Clus_Phthalates" = "Phthalates")
# 
# met_clus10 <- met_clus2b %>% filter(Metab_Cluster == 10)
# met_clus10b <- met_clus10 %>% left_join(all_sig2_class2b, by = "Metabolites")
# 
# 
# met_clus1 <- met_clus2b %>% filter(Metab_Cluster == 1)
# met_clus1b <- met_clus1 %>% left_join(all_sig2_class2b, by = "Metabolites") 
# 
# 
# met_clus13<- met_clus2b %>% filter(Metab_Cluster == 13)
# met_clus13b <- met_clus13 %>% left_join(all_sig2_class2b, by = "Metabolites") 


for (i in row_all2_bhcor_sum$Metab_Cluster){
  clusname <- paste0("met_clus_ind", i)
  met_clusi <- met_clus2b %>% filter(Metab_Cluster == i) %>% 
    left_join(fit_lin34_adjust_longb_wide, by = "Metabolites") %>% arrange(Class_new2)
  assign(clusname, met_clusi)
  
}

write.csv(met_clus_ind9, "cluster9.csv")
write.csv(met_clus_ind17, "cluster17.csv")
write.csv(met_clus_ind21, "cluster21.csv")

#Combine three clusters
# met_clus_ind_top3 <- rbind.data.frame(met_clus_ind10, met_clus_ind1, met_clus_ind13)

```

Now, let us plot metabolites from each cluster for Figure 2

```{r plotting metabolites from each cluster}

sigmet_clus10 <- c("DEHP", "MBZP", "MEP", "MCPP", "MCNP")
sigmet_clus13 <- c("DEHP", "DBP", "MEP", "MCPP")
sigmet_clus1 <- c("DEHP", "MCNP", "MCPP")
sigmet_clus6 <- c("MCPP")
sigmet_clus8 <- c("DEHP", "MCPP")
sigmet_clus11 <- c("MCPP")
sigmet_clus14 <- c("MCNP")
sigmet_clus16 <- c("MCPP")


datprep_tile <- function(data, vars, title){
  
  #Create the data
  dat <- data %>% select(Metabolites, Class_new2,all_of(vars))
  dat_long <- dat %>% pivot_longer(cols = vars, names_to = "Phthalates", values_to = "Beta coefficient",
                                     values_ptypes  = list(`Beta coefficient` = 'character'))
  dat_long2 <- dat_long %>% mutate(`Beta coefficient2` = substr(`Beta coefficient`, 3, 10),
                                                        signif = substr(`Beta coefficient`, 1, 1),
                                                        signif2 = ifelse(signif == 1, "*", ""))
  
  dat_long2$`Beta coefficient2` = factor(dat_long2$`Beta coefficient2`, levels = c("Negative", "Positive"))
  
  #Plot 
  
  plot1 <- ggplot(dat_long2, aes(x = Phthalates, y = Metabolites, fill = `Beta coefficient2`, label = signif2)) + 
  geom_tile() + geom_text(aes(label = signif2), col = "white") + theme_classic() + 
  scale_fill_manual(values = group.colors) +
  ggtitle(title) + theme(axis.title  = element_blank(), legend.position = "none", axis.ticks = element_blank())

    return(plot1)
  
}


clus10_plot <- datprep_tile(data = met_clus_ind10, vars = sigmet_clus10, title = "Cluster 10")
clus10_plot

clus13_plot <- datprep_tile(data = met_clus_ind13, vars = sigmet_clus13, title = "Cluster 13") 
clus13_plot

clus1_plot <- datprep_tile(data = met_clus_ind1, vars = sigmet_clus1, title = "Cluster 1") 
clus1_plot

# clus8_plot <- datprep_tile(data = met_clus_ind8, vars = sigmet_clus8, title = "Cluster 8") 
# clus8_plot
# 
clus6_plot <- datprep_tile(data = met_clus_ind6, vars = sigmet_clus6, title = "Cluster 6")
clus6_plot

clus11_plot <- datprep_tile(data = met_clus_ind11, vars = sigmet_clus11, title = "Cluster 11") 
clus11_plot

# clus14_plot <- datprep_tile(data = met_clus_ind14, vars = sigmet_clus14, title = "Cluster 14") 
# clus14_plot

clus16_plot <- datprep_tile(data = met_clus_ind16, vars = sigmet_clus16, title = "Cluster 16") 
clus16_plot

# text <- "Table 2. List of metabolic markers in significantly associated clusters. * represents metabolic markers that were significantly associated in MWAS."
# text.p <- ggpubr::ggparagraph(text = text, face = "italic", size = 11, color = "black")
# 
# ggpubr::ggarrange(clus10_plot, clus8_plot)





```












